# Antlr4 g4 语法

使用 Antlr4 解析某个语言代码段的语法树，首先需要提供这个语言的语法定义文件 .g4 。

就是用 Antlr4 元语言语法定义某个语言的语法。

计算机语言的词法分析、语法分析类似人类语言的“主谓宾定状补”等结构分析和语义分析；也用标点符号界定词法符号或句子的边界。

```g4
grammar Hello;
//这是语法分析器规则，表示的意义：匹配“忽略空格、Tab、换行、回车后以hello开头紧接着至少一个小写字母的字符串“
r: 'hello' ID ;
//这是词法分析器规则
ID: [a-z]+ ;
WS: [ \t\r\n]+ -> skip ;
```



## Antlr 语法

github 和官网上的文档讲解语法感觉都比较分散，《ANTLR4权威指南》第15章有对语法的总结．

分为下面内容（这里只是大纲）：

+ 语法词汇表

  + 注释

    `/* */`和`//`

  + 标识符

    词法符号名和词法规则名以大写字母开头

    ```
    ID : [a-zA-Z]+ ;
    ```

    文法规则名以小写字母开头

    ```
    r: 'hello' ID ;
    ```

  + 文本常量

    单引号括起来的字符串，如

    ```
    ';'
    ```

  + 动作

    使用目标语言编写的代码块

  + 关键字

    | 关键字   | 说明                                                         |
    | -------- | ------------------------------------------------------------ |
    | grammar  | Antlr 一系列规则的集合。                                     |
    | import   | 引入其他文件。                                               |
    | fragment | 将一条规则声明为 fragment 可以告诉 ANTLR，该规则本身不是一个词法符号，它只会被其他的词法规则使用。 |
    | lexer    |                                                              |
    | parser   |                                                              |
    | returns  |                                                              |
    | locals   |                                                              |
    | throws   |                                                              |
    | catch    |                                                              |
    | finally  |                                                              |
    | mode     |                                                              |
    | options  |                                                              |
    | tokens   | 定义本语法中动作所需的词法符号类型，TODO。                   |

    > 应避免使用rule作为关键字，不要使用目标语言的关键字作为词法符号、标签或规则名。

+ 语法结构

  + 通用形式

  + 混合语法

    ```
    grammer Name;			//混合语法，可以包含语法规则和词法规则
    parser grammer Name;	//纯语法规则
    lexer grammer Name; 	//纯词法规则
    ```

  + 语法级别的动作

    TODO

    + header

      为生成代码指定包名，等同于`-package`参数？

    + member

      将代码注入为识别类的字段和方法。

+ 文法规则

  + 备选分支的标签

    通过给备选分支添加标签可以获得更加精确的语法分析器监听器事件（就是监听器回调方法或访问器访问方法）。

  + 规则上下文

    每个规则引用都会生成规则上下文对象，就是解析树中的节点，都继承`ParserRuleContext`。

  + 规则元素标签

    TODO

  + 规则元素可行值
    + `T`
    + `'literal'`
    + `r`
    + `r[<<args>>]`
    + `{<<action>>}`
    + `{<<p>>}?`

  + 子规则

    + `(x|y|z)`
    + `(x|y|z)?`
    + `(x|y|z)*`
    + `(x|y|z)+`

  + 捕获异常

    每条规则都包裹在一个try/catch/finally语句中，为了在一条规则中发生语法错误时，ANTLR会捕获该异常，报告错误，并
    试图从中恢复。

    + 异常列表

  + 规则属性定义

    规则可以像编程语言中的函数一样,包含参数、返回值以及局部变量；ANTLR会将你定义的所有变量收集起来并存储到规则上下文对象中,这些变量通常称
    为属性。

  + 起始规则和文件结束符
    + EOF

+ 动作和属性

  + 动作

    是以目标语言编写的，位于花括号中的文本块，识别器根据它们在语法中的位置,在不同的时机触发之。

  + 属性
    + 词法符号属性
    
      动作可以通过`$<label>.<attribute>`方式访问这些属性。
    
    + 文法规则属性
    
    + 动态作用域属性

+ 词法规则

  + 词法模式

  + 词法规则元素

    参考规则元素可行值。

  + 递归词法规则
  + 冗余字符串常量
  + 词法规则动作
  + 词法分析器指令

+ 通配符与非贪婪子规则

  + 非贪婪词法子规则
  + 非贪婪文法子规则

+ 语义判定

  + 进行带判定的语法分析决策
  + 寻找可见的判定
  + 使用上下文相关判定
  + 词法规则中的判定

+ 选项

  能够改变ANTLR根据语法生成代码的方式。通用形式如下:

  ```
  options { name1=value1; ... nameN=valueN; }
  ```

  + 语法选项
  + 规则选项
  + 规则元素选项



### Antlr元语言语法标记

| 语法标记                | 说明                                 |
| ----------------------- | ------------------------------------ |
| x                       | 匹配词法符号、规则引用或者子规则 x   |
| x y ... z               | 匹配一列规则元素，必须匹配所有子规则 |
| (... \| ... \| ...)     | 一个具有多个备选分支的子规则         |
| x?                      | 匹配x或者忽略它                      |
| x*                      | 匹配x零次或多次                      |
| x+                      | 匹配x一次或多次                      |
| r : ...;                | 定义语法分析器规则                   |
| r : ... \| ... \| ... ; | 定义具有多个备选分支的规则           |
|                         |                                      |

比如匹配算术表达式的规则：

可以匹配一个加减乘除带括号的算术表达式、一个赋值的加减乘除带括号的算术表达式、或者一个直接'\r\n'、'\n'换行的空行。

```g4
// r : ...;
prog:   stat+ ; 	

//r : ... | ... | ... ;
stat:   expr NEWLINE                
    |   ID '=' expr NEWLINE     	//x y ... z
    |   NEWLINE                   
    ;

//这里的子规则排序是有讲究的，调换顺序可能解析出错误的语法树
expr:   expr ('*'|'/') expr   		//(... | ... | ...)，此处('*'|'/')是一个子规则，表示用*或/连接
    |   expr ('+'|'-') expr   
    |   INT                    
    |   ID                    
    |   '(' expr ')'         		//x y ... z
    ;

ID  :   [a-zA-Z]+ ;      // x+
INT :   [0-9]+ ;         // x+
NEWLINE:'\r'? '\n' ;     // x y ... z，可以匹配 '\r\n'、'\n'
WS  :   [ \t]+ -> skip ;
```

> ！！！ 这里发现 expr 的顺序是有讲究的，调换顺序可能导致解析出错误的语法树，暂时不清楚内部什么逻辑？TODO：可能需要研究源码
>
> ```g4
> //比如调换前两个子规则的顺序，如下，重新解析语法树中体现的优先级就完全错乱了
> expr:   expr ('+'|'-') expr 
>     |   expr ('*'|'/') expr   
>     |   INT                    
>     |   ID                    
>     |   '(' expr ')' 
>     ;
> ```



## Antlr 基础语法规则

参考 《ANTLR4权威指南》表5-3，列举了一些很常用且通用的语法规则片段。

