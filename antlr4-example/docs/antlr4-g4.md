# Antlr4 g4 语法

使用 Antlr4 解析某个语言代码段的语法树，首先需要提供这个语言的语法定义文件 .g4 。

就是用 Antlr4 元语言语法定义某个语言的语法。

计算机语言的词法分析、语法分析类似人类语言的“主谓宾定状补”等结构分析和语义分析；也用标点符号界定词法符号或句子的边界。

```g4
grammar Hello;
//这是语法分析器规则，表示的意义：匹配“忽略空格、Tab、换行、回车后以hello开头紧接着至少一个小写字母的字符串“
r: 'hello' ID ;
//这是词法分析器规则
ID: [a-z]+ ;
WS: [ \t\r\n]+ -> skip ;
```



## Antlr 元语法规则

Antlr元语法规则并没有在某个文档中有很完整梳理，而是散落在《ANTLR4权威指南》各个章节，通过一个个案例引出，不过可以看下第5章。

语法上类似正则表达式，但是作者表示比正则表达式强大。

+ **语法分析器规则以小写字母开头**

  ```
  r: 'hello' ID ;
  ```

+ **词法分析器规则以大写字母开头**

  ```
  ID : [a-zA-Z]+ ;
  ```

+ **单引号引起来的标点符号也是一个规则，表示等值匹配**

+ **备选分支的标签**

  位于备选分支右侧以`#`开头，会为每个备选分支生成不同的访问器方法

  ```
  stat:   expr NEWLINE                # printExpr
      |   ID '=' expr NEWLINE         # assign
      |   NEWLINE                     # blank
      ;
  ```

+ 

## Antlr元语言语法关键字

| 关键字  | 说明                   |
| ------- | ---------------------- |
| grammar | Antlr 一系列规则的集合 |
| import  | 引入其他文件           |
|         |                        |
|         |                        |



## Antlr元语言语法标记

| 语法标记                | 说明                                 |
| ----------------------- | ------------------------------------ |
| x                       | 匹配词法符号、规则引用或者子规则 x   |
| x y ... z               | 匹配一列规则元素，必须匹配所有子规则 |
| (... \| ... \| ...)     | 一个具有多个备选分支的子规则         |
| x?                      | 匹配x或者忽略它                      |
| x*                      | 匹配x零次或多次                      |
| x+                      | 匹配x一次或多次                      |
| r : ...;                | 定义语法分析器规则                   |
| r : ... \| ... \| ... ; | 定义具有多个备选分支的规则           |
|                         |                                      |

比如匹配算术表达式的规则：

可以匹配一个加减乘除带括号的算术表达式、一个赋值的加减乘除带括号的算术表达式、或者一个直接'\r\n'、'\n'换行的空行。

```g4
// r : ...;
prog:   stat+ ; 	

//r : ... | ... | ... ;
stat:   expr NEWLINE                
    |   ID '=' expr NEWLINE     	//x y ... z
    |   NEWLINE                   
    ;

//这里的子规则排序是有讲究的，调换顺序可能解析出错误的语法树
expr:   expr ('*'|'/') expr   		//(... | ... | ...)，此处('*'|'/')是一个子规则，表示用*或/连接
    |   expr ('+'|'-') expr   
    |   INT                    
    |   ID                    
    |   '(' expr ')'         		//x y ... z
    ;

ID  :   [a-zA-Z]+ ;      // x+
INT :   [0-9]+ ;         // x+
NEWLINE:'\r'? '\n' ;     // x y ... z，可以匹配 '\r\n'、'\n'
WS  :   [ \t]+ -> skip ;
```

> ！！！ 这里发现 expr 的顺序是有讲究的，调换顺序可能导致解析出错误的语法树，暂时不清楚内部什么逻辑？TODO：可能需要研究源码
>
> ```g4
> //比如调换前两个子规则的顺序，如下，重新解析语法树中体现的优先级就完全错乱了
> expr:   expr ('+'|'-') expr 
>     |   expr ('*'|'/') expr   
>     |   INT                    
>     |   ID                    
>     |   '(' expr ')' 
>     ;
> ```



## Antlr 基础语法规则

参考 《ANTLR4权威指南》表5-3，列举了一些很常用且通用的语法规则片段。



## 语法树节点组织结构

